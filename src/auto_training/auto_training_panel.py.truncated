    def start_local_training(self, task: TrainingTask):
        """启动本地训练"""
        task.execution_log += "[INFO] 开始本地训练任务...\n"
        
        # 检查数据集路径
        if not os.path.exists(task.dataset_path):
            raise Exception(f"数据集路径不存在: {task.dataset_path}")
        
        task.execution_log += f"[INFO] 数据集路径: {task.dataset_path}\n"
        
        # 生成训练脚本
        train_script = os.path.join(task.dataset_path, "train.py")
        task.execution_log += f"[INFO] 生成训练脚本: {train_script}\n"
        
        # TODO: 这里应该从模板生成train.py脚本
        # 目前假设脚本已存在
        if not os.path.exists(train_script):
            task.execution_log += "[WARNING] 训练脚本不存在，尝试生成...\n"
            # 这里可以添加生成逻辑
            raise Exception(f"训练脚本不存在: {train_script}")
        
        # 检查conda环境
        if task.conda_env:
            task.execution_log += f"[INFO] 检查conda环境: {task.conda_env}\n"
            if not self.check_conda_environment(task.conda_env):
                error_msg = f"conda环境 '{task.conda_env}' 不存在，请先配置conda环境"
                task.execution_log += f"[ERROR] {error_msg}\n"
                raise Exception(error_msg)
            
            # 使用conda环境构建命令
            cmd = f"conda run -n {task.conda_env} python train.py train"
            task.execution_log += f"[INFO] 使用conda环境: {task.conda_env}\n"
        else:
            # 不使用conda环境
            cmd = f"python train.py train"
            task.execution_log += "[INFO] 不使用conda环境\n"
        
        # 根据平台构建后台命令
        import platform
        system = platform.system().lower()
        
        if system == "linux" or system == "darwin":  # Linux or macOS
            # 使用nohup在后台运行，并将日志输出到train.log
            full_cmd = f"nohup {cmd} > train.log 2>&1 &"
            task.execution_log += f"[INFO] 使用平台命令启动后台训练 (Linux/macOS): {full_cmd}\n"
        elif system == "windows":
            # Windows使用start命令
            full_cmd = f"start /B {cmd} > train.log 2>&1"
            task.execution_log += f"[INFO] 使用平台命令启动后台训练 (Windows): {full_cmd}\n"
        else:
            # 其他平台使用默认方式
            full_cmd = cmd
            task.execution_log += f"[INFO] 使用默认方式启动训练: {full_cmd}\n"
        
        task.execution_log += f"[INFO] 执行命令: {full_cmd}\n"
        
        # 启动进程
        try:
            if system == "linux" or system == "darwin" or system == "windows":
                # 对于Linux/macOS/Windows，直接执行后台命令
                result = subprocess.run(full_cmd, shell=True, cwd=task.dataset_path, 
                                      stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                
                if result.returncode == 0:
                    task.execution_log += "[INFO] 后台训练任务启动成功\n"
                    if result.stdout:
                        task.execution_log += f"[OUTPUT] {result.stdout}\n"
                else:
                    task.execution_log += f"[WARNING] 后台命令执行可能存在问题: {result.stderr}\n"
                    
                # 获取进程ID（对于nohup启动的进程，需要特殊处理）
                if system == "linux" or system == "darwin":
                    # 尝试获取最近启动的python进程ID
                    try:
                        ps_result = subprocess.run("ps aux | grep 'python.*train.py' | grep -v grep | head -1 | awk '{print $2}'", 
                                                 shell=True, cwd=task.dataset_path, 
                                                 stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                        if ps_result.stdout.strip():
                            task.process_id = int(ps_result.stdout.strip())
                            task.execution_log += f"[INFO] 获取到训练进程ID: {task.process_id}\n"
                    except Exception as e:
                        task.execution_log += f"[WARNING] 无法获取训练进程ID: {str(e)}\n"
                elif system == "windows":
                    # Windows下获取进程ID比较复杂，暂时留空
                    task.execution_log += "[INFO] Windows平台下进程ID获取暂不支持\n"
            else:
                # 其他平台使用原来的Popen方式
                process = subprocess.Popen(
                    full_cmd,
                    shell=True,
                    cwd=task.dataset_path,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )
                
                if task.task_id is not None:
                    self.running_processes[task.task_id] = process
                task.process_id = process.pid
                
                task.execution_log += f"[INFO] 训练任务已启动: PID={process.pid}\n"
                logger.info(f"本地训练任务已启动: PID={process.pid}")
        except Exception as e:
            task.execution_log += f"[ERROR] 启动进程失败: {str(e)}\n"
            raise